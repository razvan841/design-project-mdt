<!-- markdownlint-disable MD024 -->
<!-- markdownlint-disable MD041 -->

## Table of Contents

- [License](#license)
- [Third-Party Licenses](#third-party-licenses)
  - [Podman](#podman)
  - [nlohmann/json](#nlohmannjson)
- [Dependencies and Requirements](#dependencies-and-requirements)
- [Running the System](#running-the-system)
- [System Limitations and Assumptions](#system-limitations-and-assumptions)
  - [Language Limitations](#language-limitations)
- [System Configurations](#system-configurations)
- [Porting the system to a remote server](#porting-the-system-to-a-remote-server)
- [Packaging as a Desktop App with Electron](#packaging-as-a-desktop-app-with-electron)
- [Project Structure](#project-structure)
- [Backend Structure Overview](#backend-structure-overview)
- [Logging](#logging)
- [Test Cases Generator](#test-cases-generator)
- [Adding a new language](#adding-a-new-language)
  - [Language checklist (make sure these are done when you add your language)](#language-checklist-make-sure-these-are-done-when-you-add-your-language)
- [Adding Additional Metrics](#adding-additional-metrics)
- [Changing how the output is parsed](#changing-how-the-output-is-parsed)
- [Testing the backend via an API testing tool](#testing-the-backend-via-an-api-testing-tool)
- [Experimental feature branch](#experimental-feature-branch)

# License

This project is licensed under the **GNU General Public License v3.0** - see the [LICENSE](LICENSE) file for details.

# Third-Party Licenses

This project makes use of the following third-party software:

## Podman

- Website: <https://podman.io/>
- License: Apache License, Version 2.0
- License text: <http://www.apache.org/licenses/LICENSE-2.0>

## nlohmann/json

- Repository: [https://github.com/nlohmann/json](https://github.com/nlohmann/json)
- License: MIT License

# Dependencies and Requirements

We require a Python version newer than 3.13.0. This is because the ```Lock``` class has been changed in 3.13, fixing some errors that would break the system in old versions of Python.

For Python library requirements, run the command:

```sh
pip install -r requirements.txt
```

For fronted development, Node.js 22.14 was used.

For React requirements and dependencies, run the commands:

```sh
cd frontend
npm install
```

# Running the System

Open two terminal windows, one for the backend and one for the frontend
For the backend, run the commands:

```sh
cd sources
python Server.py
```

For the frontend, run the commands:

```sh
cd frontend
npm start
```

# System Limitations and Assumptions

One major limitation with our system is the path. For the system to work properly, we do not accept whitespaces in the path where the system is installed.

Another assumption is the connection to the internet. This is required in order to retrieve images from docker hub. Without access to the internet, the system will not work.

## Language Limitations

The system currently has limitations with handling lists of strings in Java. Due to the way we parse and handle lists from strings to their actual value, our current system can't make use of lists of strings in Java. One solution to this would be to use a json library, but from our attempts, it did not work and it significantly slowed down Java containers.
Another assumption with Java is that the user writes just their function, without it being in a class, and make it static. This is necessary for the injector to work.

In C++, our solution for using lists requires vectors, this being the only supported way of having lists.

# System Configurations

There are multiple constants in the system that can be changed by the user. Changes might impact speed of executing code at the cost of using more resources. Below, there is a table of constants:

| Constant              | File                   | Default Value | Description |
|-----------------------|------------------------|----------------|-------------|
| `MAX_CONTAINERS`      | `ContainerManager`     | `4`            | Controls how many containers can run in parallel. Increasing it may boost performance but can exhaust system resources and cause crashes. |
| `EXECUTION_PATH`      | `DockerMaker`          | `sessions`     | Sets the folder where user-executable code will be placed. |
| `SUPPORTED_LANGUAGES` | `LanguageFactory`      | *(Varies)*     | List of accepted programming languages. Modify to support more languages. |
| `STDERR_LEVEL`        | `LoggerConfig`         | *(e.g., 20)*   | Controls logging verbosity. Higher values (e.g., `DEBUG`) give more detailed logs. |
| `PROJECTS_FOLDER`     | `Server`               | `projects`     | Defines the directory where user projects are stored. |
| *(Various values)*    | `TestCasesGenerator`   | *(Randomized)* | Customize value limits like min/max for ints, floats, strings, and list lengths used in autogenerated test cases. |

# Porting the system to a remote server

The system is designed to be easily deployed on a remote server. Several changes need to be made for this to happen.

Most important, the way jobs are executed needs a slight change. Assuming the remote server has a greater computational power than a personal computer, we suggest increasing the maximum number of containers. Additionally, slight modifications to the queueing system need to be made. Currently, if the number of max containers is reached and the system tries to add another one, it will raise an exception. This is not a problem if it is run locally since we always make sure to have a container slot empty before adding it.
We suggest modifying the system so that, instead of raising an error when no container is available, the job is add it back to the queue. This will ensure that the job will eventually be run.

If you want to store your projects remotely, there are several api routes already implemented to this end, namely ```get_projects```, ```get_project``` and ```save_project```.

# Packaging as a Desktop App with Electron

We used Electron to package the application as a desktop app. All the required scripts are already present, you simply have to use the following commands.

```sh
npm install electron electron-packager
cd frontend
npm run build
cd ..
npx electron-packager . <AppName> --platform=win32 --arch=x64 --out=dist/ --overwrite
```

This commands will package your project in the dist folder. Make sure you use the correct platform and architecture.

If you want to create a new installer, use the following commands:

```sh
npm install electron electron-builder
cd frontend
npm run build
cd ..
npm run dist:<TargetSystem>
```

Replace with the target system you want to make the installer for. If you don't specify, it will make it for your system. You can all set it for all. You can't make an installer for Mac unless you are on a Mac machine.

# Project Structure

The project is organized into several key directories and files, each serving a specific purpose:

- **Root Directory**
  Contains essential documentation and configuration files:
  - `package.json`
  - `.gitignore`
  - `requirements.txt`
  - `LICENSE`
  - `CONTRIBUTING`
  - `README.md`  
  The `main.js` file is also located here and is used for porting the project to a desktop application using Electron.

- **`sources/`**
  Contains all backend logic. Inside this folder is a `languages/` subdirectory that includes implementations for all supported programming languages.

- **`frontend/`**
  Includes the frontend code along with all required dependencies and resources.

- **`tests/`**
  Contains unit and integration test files. This directory includes subfolders necessary for setting up integration tests.

- **`resources/`**
  Hosts helper functions used by languages like C++ and Java to parse data structures (e.g., lists). You can also add your own helper files here; these will be automatically included in the containers as needed.

- **`examples/`**
  Provides useful samples such as:
  - Example projects
  - Sample functions for testing
  - Sample request and response payloads
  - Sample input/output files

# Backend Structure Overview

Below is a table that outlines the different classes and interfaces used in the backend of the system. Each component serves a specific role to ensure the proper functioning of the code execution process, container management, and system interactions.

| **Component**        | **Description**                                                                                                                                               |
|----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Server**           | Contains all the implemented API routes, with the core `execute_code` route being the central component, interacting with other classes to process requests.  |
| **Podman**           | Serves as an interface to interact with the Podman system. Most functionality related to Podman is abstracted in this class, with methods making system calls. |
| **Container**        | Models a Podman container, handling tasks like injecting and dockerizing code, making calls to Podman, modifying code, and providing related functionalities. |
| **Container Manager**| Responsible for managing containers, determining when a new container needs to be spawned, or when an existing one can be reused, and handling threading/queueing. |
| **Result Parser**    | Takes the raw output from code execution and formats it into a structured JSON object for the frontend to use.                                                 |
| **Language**         | An interface that defines how a new programming language should be implemented and integrated within the system.                                               |
| **Injector**         | Defines how a new injector for a specific language should be implemented to support injecting code into containers.                                            |
| **DockerMaker**      | Outlines how a new Docker maker should be implemented for a specific language, guiding the creation of custom Docker images.                                   |
| **LoggerConfig**     | Configures how logging appears throughout the system, ensuring proper logging setup for error tracking and debugging.                                          |
| **TestCasesGenerator**| Responsible for generating test cases based on the function signature, automating test creation for code validation.                                          |

# Logging

In order to understand what is happening on the backend, there is a logger implemented. It writes logs both in the terminal and in a backend.log file. By default, the logging file is ```backend.log``` and can be found in the `sources` folder.

To change the logging level, go to the `LoggerConfig` file and change the value of ```logger.setLevel()```. For debugging, the `DEBUG` or `STDERR_LEVEL` is recommended. For production, use either the `ERROR` or `CRITICAL` levels.

# Test Cases Generator

We have implemented the feature to generate test cases based on the signature. Currently, it is done only randomly. The generator supports all primitive types and lists and nested lists of these types. In the generation functions, you can set the ranges for the generated values. For example, the default interval for generating an int or a float is (-200, 200). This feature can be potentially be improved by adding a system that creates test cases, specifically for edge cases.

# Adding a new language

In order to add a new language, follow these steps:

- in the `languages` folder, create a new file for your new language implementation
- make a class for your language that overrides the basic `Language` class
- besides the `Language` class you have to override, you will have two subclasses: an `Injector` and a `DockerMaker`. These two subclasses inherit from base classes and must be overridden.
- override the functions you need to make the system work. Most likely changes to be required are as following:
  - `Injector` Subclass (constructor, inject, setup, wrap, cast)
  - `DockerMaker` Subclass (add_base_image, add_libraries, add_compile)
  - `Language` Class (constructor, check_signature, generate_run_command)
- make sure to also add your language to the `LanguageFactory` file
- you can add helper files in the resources folder. This can be done by overriding the ```helper_files``` attribute of the ```Language``` class. These will be added to the container alongside the user executable code.

## Language checklist (make sure these are done when you add your language)

- extension attribute (e.g. "py" for Python; don't add the ".")
- available versions/compilers (can be an empty list if language is not compiled for example)
- helper files list (it is added in the `Injector` subclass constructor as a list, there is an example in the `CppLanguage` class). We recommend to put the actual helper files in the resources folder
- base image: since the whole system works on docker images, you have to find a base image for your language. We suggest using an official image, which can be found on <https://hub.docker.com/>. Additionally, most programming languages have an `alpine image`. We suggest using these ones since it will cut down significantly on the time required to build the image. You can also check on the website what versions are supported for your programming language. For compiled languages, you can find different images with different compilers too!
- adding the `time` module: For code metrics, we use the `time` module. It is important to add it to the container if it is not installed by default. Alpine images usually have it installed, but you should check this. To add it, write an `add_time` method in the `DockerMaker` subclass and call it in the `generate_dockerfile` method. An example of this can be seen in the `CppLanguage` class.
- adding libraries: If you want your language to use libraries that need to be installed, override the `add_libraries` method.
- compiling is no longer done from the Dockerfile, so we suggest leaving this function not implemented even if you are working with a compiled language
- reference the correct `Injector` and `DockerMaker`: when overriding the `Language` class make sure the injector and dockermaker attributes point towards your language specific classes that you have overridden
- generate run/compile command: These two methods will always need to be overridden with the correct command for you specific language. **WARNING!** Even if your language is not compiled (e.g. Python), `generate_compile_command` still needs to return something. We suggest the following code: ```return ["echo", "compiled"]```.
- check signature: This method also needs to be overridden. The implementation can be copied from other `Language` classes, but be careful with language specific types, especially for lower level languages (e.g. C)
- updating `LanguageFactory`: For the language to appear on the frontend and work on the backend, make sure to add it to the match-case block in the `LanguageFactor` class. Additionally, add it to the `SUPPORTED_LANGUAGES` list

We suggest looking at already implemented languages to see what and how everything needs to be set up. The best examples are the CppLanguage and PyLanguage files.

# Adding Additional Metrics

In order to add new metrics, you have to find a way to measure them. For the metrics we already implemented, we use the `time` package present on most Linux distributions. If the metric you intend to add is outputted by `time` you already have access to it.

Additionally, the `ResultParser` will need to be changed to include the extra metric in the response. We suggest looking at already existing implementation to understand how to add a new metric.

# Changing how the output is parsed

Currently, after executing the code with all test cases, we have the raw outputs, which are then processed by the `ResultParser` class. If you want to make changes to how the outputs are parsed, we suggest inheriting the class and overwriting the functionality you wish there.

# Testing the backend via an API testing tool

For backend development, we have a couple of API request examples in the examples folder. There are also a couple files with simple cpp and python functions you can test the API with. When making your API request, the following need to be present:

- at least one code cell in the options list. In the code cell, the following is necessary:
  - `cell_id` (can be either string or number)
  - `code` (as a string)
  - `signature` (dict, including function name, args and return type)
  - `language` (necessary)
  - `version` (optional, has default value)
  - `compiler` (optional, has default value)
  - `specs` (dict, including libraries if wanted)
  - `run_as_is` (default is false)
- `timeout` flag (optional): given as an int of seconds, minimum value 5 seconds
- `generate_test_cases` flag: if you want to generate test cases automatically, set this to true and add the `test_cases_count` (optional, default = 25) and `test_cases_signature` (mandatory!)
- `manual tests`: give the input/output fields. Make sure each input and output is a list

# Experimental feature branch

In the repository you will find a branch called "experimental_features", which includes backend implementations for the following features:

- fixes timeout bug (the system didn't correctly kill the execution process, so the container will remain in execution after the timeout)
- support for configuring intervals in the TestCasesGenerator (the execute_code api route now can include a dict with intervals from which the random values are taken)
- implementation of the Go Language
- implementation of the C# Language

Lists have not been implemented in Go unfortunately

C# does have Lists implemented. For the language to work, the user is expected to only write the static method(not named `main`) and not create their own class. The user still has to include the libraries for their code. An example can be found in `\tests\C#\test_code.cs`

**WARNING!** This features might not be completely implemented or might cause bugs
